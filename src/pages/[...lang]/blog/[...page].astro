---
import { getCollection } from 'astro:content';
import MainLayout from '@/components/layout/MainLayout.astro';
import BlogCard from '@/components/blog/BlogCard.astro';
import { useTranslations } from '@/i18n/ui';
import { routes, type RouteKey } from '@/i18n/routes';
import { supportedLanguages, defaultLang, type LangCode } from '@/i18n/config';

export async function getStaticPaths({ paginate }: any) {
  const allPosts = await getCollection('blog', ({ data }) => !data.draft);
  
  return supportedLanguages.flatMap((lang) => {
    const l = lang as LangCode;
    const langPosts = allPosts
      .filter(post => post.data.lang === l)
      .sort((a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf());

    // Paginazione: genera /blog, /blog/2 oppure /it/blog, /it/blog/2
    return paginate(langPosts, {
      params: { lang: l === defaultLang ? undefined : l },
      pageSize: 12,
      props: { lang: l }
    });
  });
}

const { page, lang } = Astro.props;
const t = useTranslations(lang as LangCode);

/**
 * Generazione URL Post agnostica.
 * Costruisce: /[lang]/blog/[category-slug]/[post-slug]
 */
function getPostHref(post: any, currentLang: LangCode) {
  const postSlug = post.id.split('/').pop()?.replace(/\.(mdx|md)$/, '') || '';
  const postCatKey = post.data.category as RouteKey;
  const catSlug = routes[currentLang][postCatKey];
  const prefix = currentLang === defaultLang ? '' : `/${currentLang}`;
  
  // Usiamo 'blog' come segmento fisso ma localizzabile se necessario 
  // (qui manteniamo la coerenza con la tua struttura cartelle)
  return `${prefix}/blog/${catSlug}/${postSlug}`.replace(/\/+/g, '/');
}
---

<MainLayout lang={lang} title={t('nav.blog')}>
  <div class="monolith-container">
    <header class="blog-header animate-fade">
      <span class="section-label">{t('nav.logo')}</span>
      <h1 class="monolith-title">{t('nav.blog')}</h1>
    </header>

    <section class="blog-grid">
      {page.data.map((post: any) => (
        <BlogCard 
          title={post.data.title}
          description={post.data.description}
          date={post.data.pubDate}
          href={getPostHref(post, lang)}
        />
      ))}
    </section>

    {page.lastPage > 1 && (
      <nav class="pagination" aria-label="Pagination">
        {page.url.prev ? (
          <a href={page.url.prev} class="nav-link">← {t('search.placeholder') ? 'PREV' : 'PREV'}</a>
        ) : <span class="disabled">←</span>}
        
        <div class="page-counter">
          <span class="current">{page.currentPage}</span>
          <span class="sep">/</span>
          <span class="total">{page.lastPage}</span>
        </div>

        {page.url.next ? (
          <a href={page.url.next} class="nav-link">NEXT →</a>
        ) : <span class="disabled">→</span>}
      </nav>
    )}
  </div>
</MainLayout>

<style>
  .blog-header {
    padding: 12vh 0 6vh;
    border-bottom: 1px solid var(--gold-muted);
    margin-bottom: 4rem;
  }

  .blog-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(min(100%, 400px), 1fr));
    gap: 3rem;
    margin-bottom: 5rem;
  }

  /* Paginazione Monolith */
  .pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 3rem;
    padding: 4rem 0 8rem;
    font-weight: 900;
    letter-spacing: 0.2em;
    text-transform: uppercase;
  }

  .nav-link {
    color: var(--gold);
    transition: var(--transition);
    font-size: 0.9rem;
  }

  .nav-link:hover {
    letter-spacing: 0.4em;
  }

  .disabled {
    opacity: 0.2;
    cursor: not-allowed;
  }

  .page-counter {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 1.2rem;
  }

  .current { color: var(--gold); }
  .sep { color: var(--gold-muted); font-weight: 300; }
  .total { color: var(--text-muted); font-size: 0.9rem; }

  @media (max-width: 768px) {
    .pagination { gap: 1.5rem; }
  }
</style>